---
layout:     post
title:      "网络连接的各种超时情况解释"
subtitle:   "Time out"
date:       2023-11-21 14:31:00
author:     "Keal"
header-img: "img/tag12.jpg"
catalog: true
tags:
    - tech

---

最近线上出了一个事故, 最后排查到是客户的网络出了问题, 导致从客户网关进出的流量都被丢弃, 消息无法正常流转,业务因此也无法正常进行. 在排查的过程中,又复习了一遍网络相关的知识, 顺便深挖了一些细节.

## 网络超时

超时一般有连接超时, 写超时, 读超时. 

### 连接超时(Connect Timeout)

连接超时是发起TCP连接的时候,超时得不到响应的结果. 当向服务端发起一个http请求之前, 底层需要先建立一个TCP连接, 在这个过程中如果服务端无法在超时时间内响应SYNC包的内容,客户端就会触发连接超时异常.

### 写超时(write Timeout)

写超时是socket的send调用超时未能成功返回的结果.

![image-20231121180024427](https://raw.githubusercontent.com/kneed/typora_img_respository/main/typora/202311221504819.png)

**ChatGPT的回答:**

> 在写操作中，判断数据是否能够及时传输到接收方通常涉及底层的网络通信和缓冲区管理。下面是一些可能导致写超时的情况：
>
> 1. **发送缓冲区满：** 如果发送方写入的数据超过了发送缓冲区的容量，或者发送方写入速度过快，使得发送缓冲区满了，写操作可能会被阻塞，直到有足够的空间来容纳数据。如果等待的时间超过了设置的写超时时间，就会触发写超时。
> 2. **网络拥塞或延迟：** 如果网络遇到拥塞或者存在较大的延迟，数据传输的速度可能变得很慢，导致写操作超时。这可能是由于网络中的路由器或交换机负载过重，或者由于其他网络问题引起的。
> 3. **接收方未读取数据：** 在TCP通信中，接收方需要及时读取已发送的数据，否则发送方的写入操作可能会受到影响。如果接收方未能及时读取数据，发送方的写入操作可能会被阻塞，最终触发写超时。
> 4. **连接中断：** 如果在写入数据的过程中，TCP连接突然中断（例如，由于网络故障或对方关闭了连接），写入操作可能会失败并触发超时。
>
> 在编程中，开发者通常通过检查写入操作的返回值或捕获异常来判断写超时的发生。这可能涉及到底层套接字编程中相关的API调用，如`send`函数在某些情况下可能返回写入的字节数，如果写入操作超时或失败，返回值可能是一个错误码。

总结来说, 应用调用的send或write都是发送到缓冲区, 当发送到缓冲区的过程超过一定时间未成功时,就会触发写超时. 缓冲区写超时是因为缓冲区满, 缓冲区满是因为缓冲区的消息发不出去. 发不出去的情况很多: 例如网络拥塞或延迟导致发送很慢. 接收方未收到数据没返回收到响应,数据保存在缓冲区等待TCP的重传. 连接异常中断(指中断时对端没有发送中断信号,客户端没有感知到对方已断开连接)导致数据发不出去.

### 读超时(read Timeout)

读超时是调用recv调用但超时未能成功返回的结果

<img src="https://raw.githubusercontent.com/kneed/typora_img_respository/main/typora/202311221504788.png" alt="image-20231121180134509" style="zoom:50%;" />

**ChatGPT的回答:**

> 读超时通常发生在应用程序尝试从套接字读取数据时，但在指定的时间内未能成功读取到数据。这可能由于多种原因导致，以下是一些可能触发读超时的情况：
>
> 1. **接收缓冲区无数据：** 当应用程序尝试从套接字读取数据时，如果接收缓冲区没有待读取的数据，读操作会被阻塞。如果阻塞时间超过了设置的读超时时间，就会触发读超时。
> 2. **网络延迟或拥塞：** 如果在网络中存在延迟或拥塞，导致数据从发送方传输到接收方的时间变长，应用程序可能在尝试读取数据时经历超时。
> 3. **对方未发送足够数据：** 如果对方尚未发送足够的数据，读取操作可能会等待直到足够的数据可用或达到读超时时间。
> 4. **连接中断：** 如果在读取数据的过程中，TCP连接突然中断（例如，由于网络故障或对方关闭了连接），读取操作可能会失败并触发超时。
> 5. **非阻塞模式下未有足够数据：** 如果套接字处于非阻塞模式，并且接收缓冲区中没有足够的数据可供读取，读取操作可能会立即返回，这时需要应用程序处理返回值以判断是否发生了读超时。
>
> 读超时是为了防止应用程序在读取操作上无限期地等待。当读取操作超时时，应用程序可以选择采取适当的措施，例如关闭连接、重试读取操作、记录日志等。读超时的处理可以根据应用程序的具体需求和网络环境进行调整。

读超时与写超时的逻辑几乎是一样的

## 附

一些相关的问题和ChatGPT的回答, 就不加上自己的理解了

### 非阻塞模式和阻塞模式的区别是什么

> 非阻塞模式和阻塞模式是描述在进行输入/输出（I/O）操作时程序的行为的两种不同方式。它们的主要区别在于程序在执行 I/O 操作时是否会被阻塞。
>
> 1. **阻塞模式（Blocking Mode）：**
>    - 在阻塞模式下，当应用程序发起一个 I/O 操作（如读取或写入数据），它会等待这个操作完成后再继续执行下一步。如果 I/O 操作无法立即完成，程序将一直等待，直到数据就绪或者发生错误。
>    - 阻塞模式使得程序能够方便地等待和处理数据，但缺点是它可能导致程序在等待 I/O 操作完成时无法执行其他任务。
>
> 2. **非阻塞模式（Non-blocking Mode）：**
>    - 在非阻塞模式下，应用程序可以发起一个 I/O 操作，但它不会等待该操作完成。相反，它会立即返回，并允许程序执行其他任务。程序需要定期轮询（polling）或使用回调机制来检查 I/O 操作的状态，以确定是否已经完成。
>    - 非阻塞模式使得程序能够在等待某个 I/O 操作完成的同时执行其他任务，提高了程序的并发性。但它需要额外的代码来处理轮询或回调，使得编程模型相对复杂。
>
> 选择使用阻塞模式还是非阻塞模式通常取决于程序的需求和设计。阻塞模式可能更简单易用，适用于某些场景，但在需要处理多个并发任务的情况下，非阻塞模式可能更为灵活。有些应用程序可能会结合使用两者，根据不同的情况选择合适的模式。例如，可以在主线程中使用阻塞模式处理核心任务，而在其他线程中使用非阻塞模式进行异步 I/O 操作。

### 缓冲区的大小的限制是什么

> 缓冲区的大小受到多种因素的限制，这些因素可能涉及到硬件、操作系统以及应用程序本身的设置。以下是一些常见的限制因素：
>
> 1. **硬件限制：** 物理硬件的限制可能是缓冲区大小的一个重要因素。例如，网络适配器、磁盘驱动器等设备都有固定的缓冲区大小。超过硬件设备支持的最大缓冲区大小可能导致性能下降或错误。
>
> 2. **操作系统限制：** 操作系统可能对单个进程或线程的缓冲区大小设置了限制。这些限制可以通过操作系统的参数进行配置，例如，Linux系统中有`sysctl`参数来调整网络缓冲区的大小。
>
> 3. **应用程序限制：** 有些应用程序会在设计时明确设置缓冲区的大小，这可能受到应用程序的设计和需求的影响。例如，在编写网络应用程序时，程序员可以选择设置套接字的发送和接收缓冲区大小。
>
> 4. **文件系统限制：** 对于磁盘 I/O 操作，文件系统可能对缓冲区大小有一定的限制。例如，某些文件系统可能限制单个文件读取或写入操作的缓冲区大小。
>
> 5. **内存限制：** 缓冲区的大小受到系统内存的限制。大型缓冲区可能占用大量内存，这可能导致系统性能问题，尤其是在资源受限的环境中。
>
> 总体而言，缓冲区的大小应该在合理范围内，既能够满足应用程序的性能需求，又不至于占用过多系统资源。在设计和实现中，开发者通常需要权衡各种因素，包括硬件限制、操作系统设置、应用程序需求等。在网络编程中，合理设置套接字的缓冲区大小可以优化数据传输性能。在文件 I/O 操作中，适当的缓冲区大小也可以影响磁盘读写性能。

### 我说的是socket的缓冲区, 是否最大的上限取决于内存

> 对于套接字（socket）缓冲区的大小，的确，最大上限通常受到系统内存的限制。套接字缓冲区是内核为套接字维护的用于暂存待发送或待接收数据的内存区域。
>
> 在套接字编程中，可以通过套接字选项来设置缓冲区的大小。常见的选项包括`SO_SNDBUF`（发送缓冲区大小）和`SO_RCVBUF`（接收缓冲区大小）。这些选项的值通常是整数，表示以字节为单位的缓冲区大小。
>
> 然而，这些缓冲区大小的实际上限通常受到系统内存的限制。系统内存的可用性限制了操作系统能够为每个套接字分配的内存量。如果应用程序尝试分配大量的套接字缓冲区，而系统内存不足，可能会导致内存分配失败或性能下降。
>
> 值得注意的是，设置大型缓冲区并不总是意味着性能提升。过大的缓冲区可能导致内存浪费，并且在某些情况下，小型缓冲区可能更适合，特别是在高延迟网络环境下，因为较小的缓冲区可以更快地响应网络变化。
>
> 因此，在实际应用中，应该根据具体的网络环境和应用需求来选择合适的套接字缓冲区大小，以平衡性能和资源利用率。

### 对于TCP连接后,数据包的发送,是否每次都需要等待接收方的确认后才会从缓冲区中删除数据?

> 在TCP协议中，数据的发送和接收是通过一种称为滑动窗口（Sliding Window）的机制进行的。这个机制允许发送方在发送数据后继续发送更多的数据，而不必等待接收方的确认。确认通常是紧随着已成功接收的数据的。
>
> 具体来说，发送方维护一个发送窗口，接收方维护一个接收窗口。发送方可以在未收到接收方确认之前发送多个数据包，而不必等待每个数据包的确认。接收方收到数据后，会发送确认消息，确认成功接收的数据。发送方根据接收到的确认信息调整发送窗口的大小，从而决定可以发送多少个新的数据包。
>
> 重要的是要理解，在滑动窗口机制下，确认的目的是通知发送方接收方已经成功接收了一部分数据，并告知发送方可以发送更多数据。而并不是每个数据包都需要等待确认后才能从发送缓冲区中删除。发送方会保留未确认的数据，直到接收到确认或达到一定的超时时间，超时后会进行相应的重传。
>
> 这种机制可以提高网络的利用率，允许在等待确认的同时继续发送新的数据，从而更好地利用带宽。然而，也要注意在某些情况下，如果网络丢包率较高，可能会导致多次重传，增加网络的负担。因此，TCP在设计中需要平衡性能和可靠性。

### 那些会确认的数据保留在哪里呢

> 在TCP中，未被确认的数据会保留在发送方的发送缓冲区中。发送缓冲区是操作系统内核为每个TCP连接维护的一块内存区域，用于存储待发送但尚未得到确认的数据。每个TCP连接都有一个独立的发送缓冲区。
>
> 具体的流程如下：
>
> 1. **应用程序写入数据：** 当应用程序通过套接字进行写操作（比如`send`调用）时，数据首先会被复制到发送缓冲区。
> 2. **发送缓冲区中的数据被TCP协议栈发送：** 操作系统的TCP协议栈负责将发送缓冲区中的数据封装成TCP报文段，并通过网络发送到接收方。
> 3. **等待确认：** 发送方会等待接收方发送确认（ACK）消息，表示已经成功接收了数据。未被确认的数据会一直保留在发送缓冲区中。
> 4. **接收确认后调整发送窗口：** 一旦接收方发送了确认消息，发送方会收到确认，此时可以根据接收窗口的大小和确认的数据量来调整发送窗口，并继续发送新的数据。
> 5. **超时重传：** 如果发送方在一定的超时时间内没有收到确认，它会认为数据可能丢失，然后触发超时重传机制，重新发送未被确认的数据。
>
> 这个机制确保了TCP的可靠性，即确保数据能够安全地传输到接收方。发送缓冲区在这个过程中充当了临时存储未被确认数据的角色。

### 如果超时重传次数过多会怎么样的

> 如果超时重传次数过多，通常表明网络或接收方存在问题，导致发送方的数据在传输过程中无法成功被确认。TCP协议为了保证可靠性，会采取一些措施来应对多次重传失败的情况：
>
> 1. **连接中断：** 当超时重传次数达到一定的阈值时，TCP协议可能会判定连接存在严重问题，并主动中断连接。这意味着发送方和接收方之间的TCP连接将被关闭。
> 2. **应用层处理：** 通常，TCP连接的关闭会导致应用层得到相应的错误通知，应用程序可以根据这个通知来处理连接中断的情况，例如，重新发起连接、记录日志或采取其他合适的措施。
> 3. **自适应重传：** 一些TCP协议栈实现可能具有自适应重传机制，即根据网络条件和历史重传情况动态调整重传策略。这可以帮助适应不同网络环境下的变化，并减少过度重传。
> 4. **拥塞控制：** TCP协议的一部分是拥塞控制机制，它可以根据网络的拥塞情况来动态调整发送速率。当网络出现拥塞时，TCP协议会采取措施减缓发送速率，以避免进一步加剧拥塞。
>
> 总体而言，超时重传次数过多通常是网络不稳定或接收方出现问题的信号。TCP协议的设计是为了在这些情况下提供稳健的连接管理，确保可靠性和合理的网络资源使用。应用程序可以通过监测连接状态和处理错误通知来适应这些情况。